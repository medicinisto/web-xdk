/**
 * Response Message Model is used to update a Message with Response Data.
 *
 * 1. A Response Message is sent with the user's state changes to the Conversation.
 * 2. Each participant in the Conversation will see a Message stating what the user did.
 * 3. The server applies those changes in the Message that was Responded to;
 *    these properties are namespaced with the sender's Identity ID, and do not replace
 *    any properties of the Message.
 * 4. Each client will receive an update to their Message with the new state, which will be stored
 *    in the Message's `responses` property, where the model can then process it and where
 *    the UI can then rerender/update itself.
 *
 * Response messages are generated by the Layer.Core.MessageTypeResponseSummary class as a side effect
 * of calls to {@link Layer.Core.MessageTypeResponseSummary#addState} and {@link Layer.Core.MessageTypeResponseSummary#removeState}.
 *
 * ### Importing
 *
 * Included with the standard build. For custom build, Import with one of:
 *
 * ```
 * import '@layerhq/web-xdk/ui/messages/response/layer-response-message-model';
 * import '@layerhq/web-xdk/ui/messages/response/layer-response-message-view';
 * ```
 *
 * @class Layer.UI.messages.ResponseMessageModel
 * @extends Layer.Core.MessageTypeModel
 */
import Core from '../../../core/namespace';
import { registerStatusModel } from '../../ui-utils';
import { ErrorDictionary } from '../../../core/layer-error';
import Settings from '../../../settings';

const { getClient } = Settings;
const { MessagePart, MessageTypeModel } = Core;

export default class ResponseModel extends MessageTypeModel {
  constructor(options) {
    super(options);
    this._changeEvents = {};
  }

  /**
   * Generate all of the Layer.Core.MessagePart needed to represent this Model.
   *
   * Used for Sending the Response Message.
   *
   * @method generateParts
   * @param {Function} callback
   * @param {Layer.Core.MessagePart[]} callback.parts
   * @typescript public
   * @private
   */
  generateParts(callback) {
    if (!this.operations || !this.operations.length) {
      throw new Error('Call addOperations() before calling generateParts()');
    }
    const body = this.initBodyWithMetadata(['responseTo', 'responseToNodeId']);
    body.changes = this.operations.map(op => op.toSerializableObject());

    this.part = new MessagePart({
      mimeType: this.constructor.MIMEType,
      body: JSON.stringify(body),
    });
    const parts = [this.part];

    // Add the displayModel's MessagePart, if there is one
    if (this.displayModel) {
      this.addChildModel(this.displayModel, 'status', (moreParts) => {
        moreParts.forEach(p => parts.push(p));
        callback(parts);
      });
    } else {
      callback(parts);
    }
  }

  parseModelPart({ payload, isEdit }) {
    super.parseModelPart({ payload, isEdit });
    this.operations = payload.changes;
  }

  /**
   * On receiving a new Layer.Core.Message, parse it and setup this Model's properties.
   *
   * @method parseModelChildParts
   */
  parseModelChildParts({ changes, init }) {
    super.parseModelChildParts({ changes, init });

    // Find the displayModel in the MessageParts and create that Model.
    this.displayModel = this.getModelsByRole('status')[0] || null;

    // This code is for backwards compatability with Web XDK 1.0.0-pre1.X and will likely be removed by Web XDK 5.0.0
    // It converts a Text Model to a Status Model and uses the `message` role instead of the `status` role.
    if (!this.displayModel) {
      const part = this.message.getPartsMatchingAttribute({ role: 'message' })[0];
      if (part) {
        const StatusModel = Core.Client.getMessageTypeModelClass('StatusModel');
        this.displayModel = new StatusModel({ text: JSON.parse(part.body).text });
        this.displayModel.part = part;
      }
    }
  }

  // Used to render Last Message in the Conversation List
  getOneLineSummary() {
    const result = super.getOneLineSummary();
    return (result === this.constructor.LabelSingular) ? '' : result;
  }

  // No notification if there is no displayModel
  getNotification() {
    if (this.displayModel) {
      return super.getNotification();
    } else {
      return {};
    }
  }

  /**
   * Adds operations to be sent in the next Response Message.
   *
   * Must be called prior to creating the Response Message.
   *
   * @method addOperations
   * @param {Layer.Core.CRDT.Changes[]} operations
   * @param {Object} changeDef
   */
  addOperations(operations, changeDef) {
    if (this.message) throw new Error(ErrorDictionary.useBeforeMessageCreation);
    if (!this.operations) this.operations = [];
    this.operations.push(...operations);

    if (changeDef) {
      const stateName = operations[0].name;
      if (!this._changeEvents[stateName]) {
        this._changeEvents[stateName] = changeDef;
      } else {
        this._changeEvents[stateName].newValue = changeDef.newValue;
      }
    }
  }

  /**
   * Get all Change Operations for the specified state name that are to be sent (or are already sent) to the server.
   *
   * ```
   * const operations = responseModel.getOperationsForState('selection');
   * operations.forEach(operation => console.log(`${operation.operation}ed the value ${operation.value} from state ${operation.name}`));
   * ```
   *
   * @method getOperationsForState
   * @param {String} stateName
   * @return {Layer.Core.CRDT.Changes[]}
   */
  getOperationsForState(stateName) {
    return (this.operations || []).filter(operation => operation.name === stateName);
  }

  /**
   * Get a hash of Change Events for each state that is being changed via these operations.
   *
   * This data is only available to Response Messages that are being generated to be sent, and are not available
   * on older Response Messages.
   *
   * ```
   * // Get all changes for this Response Message
   * const changes = responseModel.getStateChanges();
   *
   * // Get changes associated with a "selection" state (or other named states)
   * const selectionChange = changes.selection;
   *
   * // Get the details from the Layer.Core.CRDT.Changes object
   * console.log(`selection changed from ${selectionChange.oldValue} to ${selectionChange.newValue}`);
   * ```
   *
   * @method getStateChanges
   * @return {Object}
   */
  getStateChanges() {
    return this._changeEvents;
  }

  /**
   * Returns the Response Summary that generated this Response Messeage.
   *
   * @method getResponseSummary
   * @returns {Layer.Core.MessageTypeResponseSummary}
   */
  getResponseSummary() {
    const message = this.responseTo ? getClient().getMessage(this.responseTo) : null;
    const part = (message && this.responseToNodeId) ? message.getPartById(`${message.id}/parts/${this.responseToNodeId}`) : null;
    if (part) {
      const model = part.createModel();
      return model.responses;
    }
    return null;
  }
}

/**
 * Array of changes to be sent to the server; add them using {@link #addOperations}
 *
 * @property {Layer.Core.CRDT.Changes[]} operations
 */
ResponseModel.prototype.operations = null;

/**
 * Hash of changes that are associated with the operations to be sent to the server.
 *
 * These are used for understanding what is to be sent to the server, but cannot be used to manipulate those changes.
 *
 * ```
 * const changes = responseModel.getStateChanges();
 * const selectionChange = changes.selection;
 * console.log(`selection changed from ${selectionChange.oldValue} to ${selectionChange.newValue}`);
 * ```
 *
 * @property {Object} _changeEvents
 * @private
 */
ResponseModel.prototype._changeEvents = null;

/**
 * Message ID of the message that this is a Response to.  Used by the server,
 * to identify which Message to update.
 *
 * @property {String} responseTo
 */
ResponseModel.prototype.responseTo = '';

/**
 * Node ID of the MessagePart that this is a Response to.
 *
 * Used by the server, to identify which MessagePart to update.  In the event that
 * a Carousel contains Choice Buttons/Choice Messages, the Response Message is a response
 * to the Choice Message, not the Carousel and needs to target it specifically.
 *
 * @property {String} responseToNodeId
 */
ResponseModel.prototype.responseToNodeId = '';

/**
 * The displayable portion of this message that is shown to users, represented as a Message Model.
 *
 * @property {Layer.Core.MessageTypeModel} displayModel
 */
ResponseModel.prototype.displayModel = null;

/**
 * One instance of this type
 *
 * @static
 * @property {String} [LabelSingular=Response]
 */
ResponseModel.LabelSingular = 'Response';

/**
 * One instance of this type
 *
 * @static
 * @property {String} [LabelPlural=Responses]
 */
ResponseModel.LabelPlural = 'Responses';

/**
 * Standard concise representation of this Message Type
 *
 * @static
 * @property {String} [SummaryTemplate=${itemCount} ${label}]
 */
ResponseModel.SummaryTemplate = '${displayModel}'; // eslint-disable-line no-template-curly-in-string


/**
 * The MIME Type recognized by and used by the Response Model.
 *
 * @static
 * @property {String} [MIMEType=application/vnd.layer.response+json]
 */
ResponseModel.MIMEType = 'application/vnd.layer.response-v2+json';

/**
 * Misc MIME Types accepted by this Model
 *
 * @static
 * @property {String[]} AltMIMETypes
 */
ResponseModel.AltMIMETypes = ['application/vnd.layer.response+json'];

/**
 * The UI Component to render the Response Model.
 *
 * @static
 * @property {String} [messageRenderer=layer-response-message-view]
 */
ResponseModel.messageRenderer = 'layer-response-message-view';

// Register the Message Model Class with the Client
Core.Client.registerMessageTypeModelClass(ResponseModel, 'ResponseModel');

// Register the Class
Core.Root.initClass.apply(ResponseModel, [ResponseModel, 'ResponseModel']);

// Register the message to be handled as a Status Message
registerStatusModel(ResponseModel);
